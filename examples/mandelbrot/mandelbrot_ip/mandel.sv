//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.11-2021/01/28-beta
//`include "sp_default.vh" //_\SV
   // For exporting the kernel, use --bestsv --noline, and cut debug sigs statements from _gen file.

   // ==========================
   // Mandelbrot Set Calculation
   // ==========================

   // To relax Verilator compiler checking:
   /* verilator lint_off UNOPTFLAT */

   //TODO re-enable
   /* verilator lint_off WIDTH */
   /* verilator lint_off REALCVT */  // !!! SandPiper DEBUGSIGS BUG.


   // M4_PE_CNT engines compute pixel depths (in reading order) for a given image.
   // Image width must be a multiple of M4_PE_CNT or things could break.
   // PEs start at the same time.
   // Each may finish at different times, but all wait for the last to complete.
   // For each pixel calculation for each PE, computation proceeds through:
   //   o an "init" cycle where values are initialized based on pixel parameters
   //   o any number of "calc" cycles
   //   o a "done" cycle ("done_pulse")
   //   o any number of "wait" cycles ("done" but not "done_pulse")
   //   o (repeat)
   // Kernel has one active frame at a time, from the acceptance of config data to the transmission of the last data out.



   // Parameters:

   // Number of replicated Processing Elements
   

   

   // Fixed numbers (sign, int, fraction)
	// Fixed values are < 8.0.
	// There are two bit widths, normal and extended:
	// 	- Extended is used for X and Y coordinates calculation to avoid
	//      the accumulation of the rounding error as pixel width is added
   

	// Extended precision
   
	

	// Data width for the incoming configuration data
	

	// Interleaving computation cycles
	

	// PE pipeline depth
	
   // Latency between last pixel calculation and first of next pixels.
   
   // Min latency between last pixels of one frame and the first of the next.
   

   // Constants and computed values:
   // Bit indices for fixed numbers
	// 	- [X:0] = integer portion
	// 	- [-1:Y] = fractional portion

	
   

	// Fixed point definition
   
   
   

   // Extended fixed point definitions
	
	
	
	//m4_makerchip_module
   // Zero extend to given width.
   `define ZX(val, width) {{1'b0{width-$bits(val)}}, val}


//TODO ifdef Makerchip



   module mandelbrot_kernel #(
     parameter integer C_DATA_WIDTH = 512 // Data width of both input and output data
   )
   (
     input wire                       axi_clk,
     input wire                       axi_reset_n,

     output wire                      s_axis_ready,
     input wire                       s_axis_valid,
     input wire  [C_DATA_WIDTH-1:0]   s_axis_data,

     input wire                       m_axis_ready,
     output wire                      m_axis_valid,
     output wire [C_DATA_WIDTH-1:0]   m_axis_data

   );
   //RPHAX Signal Names

   wire clk = axi_clk;
   wire reset = axi_reset_n; //Reset is positive logic ignore _n
   //Incoming data from DMA + ready -- AXI Stream Slave
   wire in_avail = s_axis_valid;
   wire [C_DATA_WIDTH-1:0] in_data = s_axis_data;
   wire in_ready = s_axis_ready;
   //Outgoing data to DMA + ready -- AXI Stream Master
   wire out_ready = m_axis_ready;
   wire out_avail = m_axis_valid;
   wire [C_DATA_WIDTH-1:0]   out_data = m_axis_data;



   function logic [3:-29] fixed_mul (input logic [3:-29] v1, v2);
      logic [3-1:0] drop_bits;
      logic [29-1:0] insignificant_bits;
      {fixed_mul[3], drop_bits, fixed_mul[2:-29], insignificant_bits} =
         {v1[3] ^ v2[3], ({{32{1'b0}}, v1[2:-29]} * {{32{1'b0}}, v2[2:-29]})};
   endfunction;

   function logic [3:-29] fixed_add (input logic [3:-29] v1, v2, input logic sub);
      logic [3:-29] binary_v2;
      binary_v2 = fixed_to_binary(v1) +
                  fixed_to_binary({v2[3] ^ sub, v2[2:-29]});
      fixed_add = binary_to_fixed(binary_v2);
   endfunction;

   function logic [3:-29] fixed_to_binary (input logic [3:-29] f);
      fixed_to_binary =
         f[3]
            ? // Flip non-sign bits and add one. (Adding one is insignificant, so we save hardware and don't do it.)
              {1'b1, ~f[2:-29] /* + {{32-1{1'b0}}, 1'b1} */}
            : f;
   endfunction;

   function logic [3:-29] binary_to_fixed (input logic [3:-29] b);
      // The conversion is symmetric.
      binary_to_fixed = fixed_to_binary(b);
   endfunction;

   function logic [3:-29] real_to_fixed (input logic [63:0] b);
      real_to_fixed = {b[63], {1'b1, b[51:53-32]} >> (-(b[62:52] - 1023) + 3 - 1)};
   endfunction;

   function logic [3:-39] real_to_ext_fixed (input logic [63:0] b);
      real_to_ext_fixed = {b[63], {1'b1, b[51:53-42]} >> (-(b[62:52] - 1023) + 3 - 1)};
   endfunction;

genvar pe;


//
// Scope: |pipe
//

// For |pipe$all_pix_done.
logic PIPE_all_pix_done_a4;

// For |pipe$config_data_bogus.
logic [63:0] PIPE_config_data_bogus_n1;

// For |pipe$config_data_min_x.
logic [63:0] PIPE_config_data_min_x_n1,
             PIPE_config_data_min_x_a0;

// For |pipe$config_data_min_y.
logic [63:0] PIPE_config_data_min_y_n1,
             PIPE_config_data_min_y_a0;

// For |pipe$config_data_pix_x.
logic [63:0] PIPE_config_data_pix_x_n1,
             PIPE_config_data_pix_x_a0;

// For |pipe$config_data_pix_y.
logic [63:0] PIPE_config_data_pix_y_n1,
             PIPE_config_data_pix_y_a0;

// For |pipe$config_img_size_x.
logic [63:0] PIPE_config_img_size_x_n1;
logic [31:0] PIPE_config_img_size_x_a0;

// For |pipe$config_img_size_y.
logic [63:0] PIPE_config_img_size_y_n1;
logic [31:0] PIPE_config_img_size_y_a0;

// For |pipe$config_max_depth.
logic [63:0] PIPE_config_max_depth_n1;
logic [31:0] PIPE_config_max_depth_a0;

// For |pipe$done_frame.
logic PIPE_done_frame_a4,
      PIPE_done_frame_a5,
      PIPE_done_frame_a6,
      PIPE_done_frame_a7,
      PIPE_done_frame_a8,
      PIPE_done_frame_a9,
      PIPE_done_frame_a10;

// For |pipe$done_pixels.
logic PIPE_done_pixels_a4;

// For |pipe$frame_active.
logic PIPE_frame_active_a0,
      PIPE_frame_active_a1;

// For |pipe$in_avail.
logic PIPE_in_avail_n1;

// For |pipe$in_data.
logic [511:0] PIPE_in_data_n1;

// For |pipe$in_ready.
logic PIPE_in_ready_n1;

// For |pipe$init_pixels.
logic PIPE_init_pixels_a0;

// For |pipe$max_depth.
logic [31:0] PIPE_max_depth_a0,
             PIPE_max_depth_a1,
             PIPE_max_depth_a2,
             PIPE_max_depth_a3;

// For |pipe$min_x.
logic [3:-29] PIPE_min_x_a0,
              PIPE_min_x_a1,
              PIPE_min_x_a2;

// For |pipe$min_y.
logic [3:-29] PIPE_min_y_a0,
              PIPE_min_y_a1,
              PIPE_min_y_a2;

// For |pipe$out_avail.
logic PIPE_out_avail_a4;

// For |pipe$out_data.
logic [511:0] PIPE_out_data_a4;

// For |pipe$out_ready.
logic PIPE_out_ready_a4;

// For |pipe$out_valid.
logic PIPE_out_valid_a4;

// For |pipe$pix_x.
logic [3:-39] PIPE_pix_x_a0,
              PIPE_pix_x_a1;
logic [2:-39] PIPE_pix_x_a2;

// For |pipe$pix_y.
logic [3:-39] PIPE_pix_y_a0,
              PIPE_pix_y_a1;
logic [2:-39] PIPE_pix_y_a2;

// For |pipe$reset.
logic PIPE_reset_n2,
      PIPE_reset_n1,
      PIPE_reset_a0,
      PIPE_reset_a1,
      PIPE_reset_a2,
      PIPE_reset_a3,
      PIPE_reset_a4;

// For |pipe$size_x.
logic [3:-29] PIPE_size_x_a0,
              PIPE_size_x_a1;

// For |pipe$size_y.
logic [3:-29] PIPE_size_y_a0,
              PIPE_size_y_a1;

// For |pipe$start_frame.
logic PIPE_start_frame_a0;

// For |pipe$valid_config_data_in.
logic PIPE_valid_config_data_in_n1,
      PIPE_valid_config_data_in_a0;

//
// Scope: |pipe/pe[15:0]
//

// For |pipe/pe$aa.
logic [3:-29] PIPE_Pe_aa_a2 [15:0],
              PIPE_Pe_aa_a3 [15:0];

// For |pipe/pe$aa_sq.
logic [3:-29] PIPE_Pe_aa_sq_a3 [15:0];

// For |pipe/pe$aa_sq_minus_bb_sq.
logic [3:-29] PIPE_Pe_aa_sq_minus_bb_sq_a3 [15:0];

// For |pipe/pe$aa_sq_plus_bb_sq.
logic [3:-29] PIPE_Pe_aa_sq_plus_bb_sq_a3 [15:0];

// For |pipe/pe$aa_times_bb.
logic [3:-29] PIPE_Pe_aa_times_bb_a3 [15:0];

// For |pipe/pe$aa_times_bb_times_2.
logic [3:-29] PIPE_Pe_aa_times_bb_times_2_a3 [15:0];

// For |pipe/pe$bb.
logic [3:-29] PIPE_Pe_bb_a2 [15:0],
              PIPE_Pe_bb_a3 [15:0];

// For |pipe/pe$bb_sq.
logic [3:-29] PIPE_Pe_bb_sq_a3 [15:0];

// For |pipe/pe$calc_valid.
logic PIPE_Pe_calc_valid_a3 [15:0],
      PIPE_Pe_calc_valid_a4 [15:0];

// For |pipe/pe$depth.
logic [31:0] PIPE_Pe_depth_a0 [15:0],
             PIPE_Pe_depth_a1 [15:0],
             PIPE_Pe_depth_a2 [15:0],
             PIPE_Pe_depth_a3 [15:0];

// For |pipe/pe$depth_out.
logic [15:0] [31:0] PIPE_Pe_depth_out_a3,
                    PIPE_Pe_depth_out_a4;

// For |pipe/pe$done_pix.
logic [15:0] PIPE_Pe_done_pix_a3,
             PIPE_Pe_done_pix_a4;

// For |pipe/pe$done_pix_pulse.
logic PIPE_Pe_done_pix_pulse_a3 [15:0];

// For |pipe/pe$init_pix.
logic PIPE_Pe_init_pix_a0 [15:0],
      PIPE_Pe_init_pix_a1 [15:0],
      PIPE_Pe_init_pix_a2 [15:0],
      PIPE_Pe_init_pix_a3 [15:0],
      PIPE_Pe_init_pix_a4 [15:0];

// For |pipe/pe$last_h.
logic [15:0] PIPE_Pe_last_h_a1,
             PIPE_Pe_last_h_a2,
             PIPE_Pe_last_h_a3,
             PIPE_Pe_last_h_a4;

// For |pipe/pe$last_v.
logic [15:0] PIPE_Pe_last_v_a1,
             PIPE_Pe_last_v_a2,
             PIPE_Pe_last_v_a3,
             PIPE_Pe_last_v_a4;

// For |pipe/pe$pix_h.
logic [31:0] PIPE_Pe_pix_h_a0 [15:0],
             PIPE_Pe_pix_h_a1 [15:0],
             PIPE_Pe_pix_h_a2 [15:0];

// For |pipe/pe$pix_v.
logic [31:0] PIPE_Pe_pix_v_a0 [15:0],
             PIPE_Pe_pix_v_a1 [15:0],
             PIPE_Pe_pix_v_a2 [15:0];

// For |pipe/pe$reset.
logic PIPE_Pe_reset_a0 [15:0],
      PIPE_Pe_reset_a1 [15:0],
      PIPE_Pe_reset_a2 [15:0],
      PIPE_Pe_reset_a3 [15:0];

// For |pipe/pe$xx.
logic [3:-29] PIPE_Pe_xx_a2 [15:0],
              PIPE_Pe_xx_a3 [15:0];

// For |pipe/pe$xx_mul.
logic [2:-39] PIPE_Pe_xx_mul_a2 [15:0];

// For |pipe/pe$yy.
logic [3:-29] PIPE_Pe_yy_a2 [15:0],
              PIPE_Pe_yy_a3 [15:0];

// For |pipe/pe$yy_mul.
logic [2:-39] PIPE_Pe_yy_mul_a2 [15:0];



   //
   // Scope: |pipe
   //

      // For $config_data_min_x.
      always_ff @(posedge clk) PIPE_config_data_min_x_a0[63:0] <= PIPE_config_data_min_x_n1[63:0];

      // For $config_data_min_y.
      always_ff @(posedge clk) PIPE_config_data_min_y_a0[63:0] <= PIPE_config_data_min_y_n1[63:0];

      // For $config_data_pix_x.
      always_ff @(posedge clk) PIPE_config_data_pix_x_a0[63:0] <= PIPE_config_data_pix_x_n1[63:0];

      // For $config_data_pix_y.
      always_ff @(posedge clk) PIPE_config_data_pix_y_a0[63:0] <= PIPE_config_data_pix_y_n1[63:0];

      // For $config_img_size_x.
      always_ff @(posedge clk) PIPE_config_img_size_x_a0[31:0] <= PIPE_config_img_size_x_n1[31:0];

      // For $config_img_size_y.
      always_ff @(posedge clk) PIPE_config_img_size_y_a0[31:0] <= PIPE_config_img_size_y_n1[31:0];

      // For $config_max_depth.
      always_ff @(posedge clk) PIPE_config_max_depth_a0[31:0] <= PIPE_config_max_depth_n1[31:0];

      // For $done_frame.
      always_ff @(posedge clk) PIPE_done_frame_a5 <= PIPE_done_frame_a4;
      always_ff @(posedge clk) PIPE_done_frame_a6 <= PIPE_done_frame_a5;
      always_ff @(posedge clk) PIPE_done_frame_a7 <= PIPE_done_frame_a6;
      always_ff @(posedge clk) PIPE_done_frame_a8 <= PIPE_done_frame_a7;
      always_ff @(posedge clk) PIPE_done_frame_a9 <= PIPE_done_frame_a8;
      always_ff @(posedge clk) PIPE_done_frame_a10 <= PIPE_done_frame_a9;

      // For $frame_active.
      always_ff @(posedge clk) PIPE_frame_active_a1 <= PIPE_frame_active_a0;

      // For $max_depth.
      always_ff @(posedge clk) PIPE_max_depth_a1[31:0] <= PIPE_max_depth_a0[31:0];
      always_ff @(posedge clk) PIPE_max_depth_a2[31:0] <= PIPE_max_depth_a1[31:0];
      always_ff @(posedge clk) PIPE_max_depth_a3[31:0] <= PIPE_max_depth_a2[31:0];

      // For $min_x.
      always_ff @(posedge clk) PIPE_min_x_a1[3:-29] <= PIPE_min_x_a0[3:-29];
      always_ff @(posedge clk) PIPE_min_x_a2[3:-29] <= PIPE_min_x_a1[3:-29];

      // For $min_y.
      always_ff @(posedge clk) PIPE_min_y_a1[3:-29] <= PIPE_min_y_a0[3:-29];
      always_ff @(posedge clk) PIPE_min_y_a2[3:-29] <= PIPE_min_y_a1[3:-29];

      // For $pix_x.
      always_ff @(posedge clk) PIPE_pix_x_a1[3:-39] <= PIPE_pix_x_a0[3:-39];
      always_ff @(posedge clk) PIPE_pix_x_a2[2:-39] <= PIPE_pix_x_a1[2:-39];

      // For $pix_y.
      always_ff @(posedge clk) PIPE_pix_y_a1[3:-39] <= PIPE_pix_y_a0[3:-39];
      always_ff @(posedge clk) PIPE_pix_y_a2[2:-39] <= PIPE_pix_y_a1[2:-39];

      // For $reset.
      always_ff @(posedge clk) PIPE_reset_n1 <= PIPE_reset_n2;
      always_ff @(posedge clk) PIPE_reset_a0 <= PIPE_reset_n1;
      always_ff @(posedge clk) PIPE_reset_a1 <= PIPE_reset_a0;
      always_ff @(posedge clk) PIPE_reset_a2 <= PIPE_reset_a1;
      always_ff @(posedge clk) PIPE_reset_a3 <= PIPE_reset_a2;
      always_ff @(posedge clk) PIPE_reset_a4 <= PIPE_reset_a3;

      // For $size_x.
      always_ff @(posedge clk) PIPE_size_x_a1[3:-29] <= PIPE_size_x_a0[3:-29];

      // For $size_y.
      always_ff @(posedge clk) PIPE_size_y_a1[3:-29] <= PIPE_size_y_a0[3:-29];

      // For $valid_config_data_in.
      always_ff @(posedge clk) PIPE_valid_config_data_in_a0 <= PIPE_valid_config_data_in_n1;


      //
      // Scope: /pe[15:0]
      //
      generate for (pe = 0; pe <= 15; pe++) begin : L1gen_PIPE_Pe
         // For $aa.
         always_ff @(posedge clk) PIPE_Pe_aa_a3[pe][3:-29] <= PIPE_Pe_aa_a2[pe][3:-29];

         // For $bb.
         always_ff @(posedge clk) PIPE_Pe_bb_a3[pe][3:-29] <= PIPE_Pe_bb_a2[pe][3:-29];

         // For $calc_valid.
         always_ff @(posedge clk) PIPE_Pe_calc_valid_a4[pe] <= PIPE_Pe_calc_valid_a3[pe];

         // For $depth.
         always_ff @(posedge clk) PIPE_Pe_depth_a1[pe][31:0] <= PIPE_Pe_depth_a0[pe][31:0];
         always_ff @(posedge clk) PIPE_Pe_depth_a2[pe][31:0] <= PIPE_Pe_depth_a1[pe][31:0];
         always_ff @(posedge clk) PIPE_Pe_depth_a3[pe][31:0] <= PIPE_Pe_depth_a2[pe][31:0];

         // For $depth_out.
         always_ff @(posedge clk) PIPE_Pe_depth_out_a4[pe][31:0] <= PIPE_Pe_depth_out_a3[pe][31:0];

         // For $done_pix.
         always_ff @(posedge clk) PIPE_Pe_done_pix_a4[pe] <= PIPE_Pe_done_pix_a3[pe];

         // For $init_pix.
         always_ff @(posedge clk) PIPE_Pe_init_pix_a1[pe] <= PIPE_Pe_init_pix_a0[pe];
         always_ff @(posedge clk) PIPE_Pe_init_pix_a2[pe] <= PIPE_Pe_init_pix_a1[pe];
         always_ff @(posedge clk) PIPE_Pe_init_pix_a3[pe] <= PIPE_Pe_init_pix_a2[pe];
         always_ff @(posedge clk) PIPE_Pe_init_pix_a4[pe] <= PIPE_Pe_init_pix_a3[pe];

         // For $last_h.
         always_ff @(posedge clk) PIPE_Pe_last_h_a2[pe] <= PIPE_Pe_last_h_a1[pe];
         always_ff @(posedge clk) PIPE_Pe_last_h_a3[pe] <= PIPE_Pe_last_h_a2[pe];
         always_ff @(posedge clk) PIPE_Pe_last_h_a4[pe] <= PIPE_Pe_last_h_a3[pe];

         // For $last_v.
         always_ff @(posedge clk) PIPE_Pe_last_v_a2[pe] <= PIPE_Pe_last_v_a1[pe];
         always_ff @(posedge clk) PIPE_Pe_last_v_a3[pe] <= PIPE_Pe_last_v_a2[pe];
         always_ff @(posedge clk) PIPE_Pe_last_v_a4[pe] <= PIPE_Pe_last_v_a3[pe];

         // For $pix_h.
         always_ff @(posedge clk) PIPE_Pe_pix_h_a1[pe][31:0] <= PIPE_Pe_pix_h_a0[pe][31:0];
         always_ff @(posedge clk) PIPE_Pe_pix_h_a2[pe][31:0] <= PIPE_Pe_pix_h_a1[pe][31:0];

         // For $pix_v.
         always_ff @(posedge clk) PIPE_Pe_pix_v_a1[pe][31:0] <= PIPE_Pe_pix_v_a0[pe][31:0];
         always_ff @(posedge clk) PIPE_Pe_pix_v_a2[pe][31:0] <= PIPE_Pe_pix_v_a1[pe][31:0];

         // For $reset.
         always_ff @(posedge clk) PIPE_Pe_reset_a1[pe] <= PIPE_Pe_reset_a0[pe];
         always_ff @(posedge clk) PIPE_Pe_reset_a2[pe] <= PIPE_Pe_reset_a1[pe];
         always_ff @(posedge clk) PIPE_Pe_reset_a3[pe] <= PIPE_Pe_reset_a2[pe];

         // For $xx.
         always_ff @(posedge clk) PIPE_Pe_xx_a3[pe][3:-29] <= PIPE_Pe_xx_a2[pe][3:-29];

         // For $yy.
         always_ff @(posedge clk) PIPE_Pe_yy_a3[pe][3:-29] <= PIPE_Pe_yy_a2[pe][3:-29];

      end
     endgenerate


   logic frame_done;  // Instrumentation-only. Used to end simulation.
generate //_\TLV

   //_|pipe
      
      // SV<->TLV for incoming data interface.
      //_@-2
         assign PIPE_reset_n2 = reset;
      //_@-1
         assign in_ready = PIPE_in_ready_n1;
         assign PIPE_in_avail_n1 = in_avail;
         assign PIPE_in_data_n1[C_DATA_WIDTH-1:0] = in_data;
         
      
      //_@-1
         assign PIPE_in_ready_n1 = ! PIPE_frame_active_a0;  // One frame at a time. Must be a one-cycle loop.
         assign PIPE_valid_config_data_in_n1 = PIPE_in_avail_n1 && PIPE_in_ready_n1;
         assign {PIPE_config_data_bogus_n1[63:0],
          PIPE_config_max_depth_n1[63:0],
          PIPE_config_img_size_y_n1[63:0],
          PIPE_config_img_size_x_n1[63:0],
          PIPE_config_data_pix_y_n1[63:0],
          PIPE_config_data_pix_x_n1[63:0],
          PIPE_config_data_min_y_n1[63:0],
          PIPE_config_data_min_x_n1[63:0]} = PIPE_in_data_n1;

         //`BOGUS_USE(PIPE_config_data_bogus_n1)
      //_@0
         // Pulse for first calc of a new frame.
         assign PIPE_start_frame_a0 = PIPE_valid_config_data_in_a0;  // Note, can assert only once the hardware is idle.
         assign PIPE_frame_active_a0 = PIPE_reset_a0 ? 1'b0 :
                         PIPE_start_frame_a0 ? 1'b1 :
                         PIPE_done_frame_a5 ? 0'b0 :  // (Falling edge alignment is arbitrary to meet timing.)
                         PIPE_frame_active_a1;

         // The computation is interleaved across M4_ITER cycles/strings

         // Val holds the valid condition for the computation
         // $val = $reset ? 0 : $start_frame || >>M4_ITER$val;
         //
         // ViewBox (fly-through)
         //
         // The view, given by upper-left corner coords and pixel x & y size.
         // It is initialized by the input FIFO
         assign PIPE_min_x_a0[3:-29] = PIPE_reset_a0 ? '0 : PIPE_valid_config_data_in_a0 ? real_to_fixed(PIPE_config_data_min_x_a0) : PIPE_min_x_a1[3:-29];
         assign PIPE_min_y_a0[3:-29] = PIPE_reset_a0 ? '0 : PIPE_valid_config_data_in_a0 ? real_to_fixed(PIPE_config_data_min_y_a0) : PIPE_min_y_a1[3:-29];
         assign PIPE_pix_x_a0[3:-39] = PIPE_reset_a0 ? '0 : PIPE_valid_config_data_in_a0 ? real_to_ext_fixed(PIPE_config_data_pix_x_a0) : PIPE_pix_x_a1[3:-39];
         assign PIPE_pix_y_a0[3:-39] = PIPE_reset_a0 ? '0 : PIPE_valid_config_data_in_a0 ? real_to_ext_fixed(PIPE_config_data_pix_y_a0) : PIPE_pix_y_a1[3:-39];

         // The size of the image. (M4_FIXED_RANGE???)
         assign PIPE_size_x_a0[3:-29] = PIPE_reset_a0 ? '0 : PIPE_valid_config_data_in_a0 ? PIPE_config_img_size_x_a0[31:0] : PIPE_size_x_a1[3:-29];
         assign PIPE_size_y_a0[3:-29] = PIPE_reset_a0 ? '0 : PIPE_valid_config_data_in_a0 ? PIPE_config_img_size_y_a0[31:0] : PIPE_size_y_a1[3:-29];

         assign PIPE_max_depth_a0[31:0] = PIPE_reset_a0 ? '0 : PIPE_valid_config_data_in_a0 ? PIPE_config_max_depth_a0[31:0] : PIPE_max_depth_a1[31:0];

         // Pulse for first valid calc cycle of new pixels.
         assign PIPE_init_pixels_a0 = PIPE_reset_a0 ? 1'b0 :
                                 (PIPE_start_frame_a0 || (PIPE_done_pixels_a4 && ! PIPE_done_frame_a4));

      for (pe = 0; pe <= 15; pe++) begin : L1_PIPE_Pe //_/pe
         //_@0
            // Reset signal
            assign PIPE_Pe_reset_a0[pe] = PIPE_reset_a0;

            assign PIPE_Pe_init_pix_a0[pe] = PIPE_init_pixels_a0;
            
            // Assign next iteration values. Reset and last of frame resets values.
            assign PIPE_Pe_depth_a0[pe][31:0] =
               PIPE_Pe_reset_a0[pe]       ? '0      :
               PIPE_Pe_init_pix_a0[pe]    ? '0      :
                              PIPE_Pe_depth_a1[pe] + 1;
            assign PIPE_Pe_pix_h_a0[pe][31:0] =
               PIPE_Pe_reset_a0[pe]            ? pe :
               PIPE_start_frame_a0 ? pe :
               PIPE_Pe_init_pix_a0[pe]         ? PIPE_Pe_last_h_a1[pe] ? pe :
                                                      PIPE_Pe_pix_h_a1[pe] + 16 :
                                   PIPE_Pe_pix_h_a1[pe];
            assign PIPE_Pe_pix_v_a0[pe][31:0] =
               PIPE_Pe_reset_a0[pe]                          ? '0 :
               (PIPE_Pe_init_pix_a0[pe] && PIPE_Pe_last_h_a1[pe]) ? PIPE_Pe_last_v_a1[pe] ? '0 :
                                                                    PIPE_Pe_pix_v_a1[pe] + 1 :
                                                 PIPE_Pe_pix_v_a1[pe];

         //_@1
            //
            // Screen render control
            //


            // Cycle over pixels (vertical (outermost) and horizontal) and depth (innermost).
            // When each wraps, increment the next.
            assign PIPE_Pe_last_h_a1[pe] = PIPE_Pe_pix_h_a1[pe] >= PIPE_size_x_a1 - 16;  // TODO: If size_x is not a multiple of M4_PE_CNT, things will go awry!
            assign PIPE_Pe_last_v_a1[pe] = PIPE_Pe_pix_v_a1[pe] == PIPE_size_y_a1 - 1;

            //
            // Map pixels to x,y coords
            //


         //_@2
            // The coordinates of the pixel we are working on.
            // $xx = $init_pix ? $MinX + $PixX * $PixH : $RETAIN;  (in fixed-point)
            assign PIPE_Pe_xx_mul_a2[pe][2:-39] =
               (PIPE_pix_x_a2[2:-39] * `ZX(PIPE_Pe_pix_h_a2[pe], 42));
            assign PIPE_Pe_xx_a2[pe][3:-29] =
               PIPE_Pe_init_pix_a2[pe] ? fixed_add(PIPE_min_x_a2[3:-29],
                                     {1'b0, PIPE_Pe_xx_mul_a2[pe][2:-29]},
                                     1'b0)
                         : PIPE_Pe_xx_a3[pe];
            // $yy = $init_pix ? $MinY + $PixY * $PixV : $RETAIN;  (in fixed-point)
            assign PIPE_Pe_yy_mul_a2[pe][2:-39] =
               (PIPE_pix_y_a2[2:-39] * `ZX(PIPE_Pe_pix_v_a2[pe], 42));
            assign PIPE_Pe_yy_a2[pe][3:-29] =
               PIPE_Pe_init_pix_a2[pe] ? fixed_add(PIPE_min_y_a2[3:-29],
                                     {1'b0, PIPE_Pe_yy_mul_a2[pe][2:-29]},
                                     1'b0)
                         : PIPE_Pe_yy_a3[pe];

         //_@3
            //
            // Mandelbrot Calculation
            //
            // Mandelbrot algorithm:
            // a = 0.0
            // b = 0.0
            // depth = 0
            // for depth [0..max_depth] until diverged {  // one iteration per cycle
            //   a <= a*a - b*b + x
            //   b <= 2*a*b + y
            //   diverged = a*a + b*b >= 2.0*2.0
            // }
            assign PIPE_Pe_aa_sq_a3[pe][3:-29] = fixed_mul(PIPE_Pe_aa_a3[pe], PIPE_Pe_aa_a3[pe]);
            assign PIPE_Pe_bb_sq_a3[pe][3:-29] = fixed_mul(PIPE_Pe_bb_a3[pe], PIPE_Pe_bb_a3[pe]);
            assign PIPE_Pe_aa_sq_plus_bb_sq_a3[pe][3:-29] = fixed_add(PIPE_Pe_aa_sq_a3[pe], PIPE_Pe_bb_sq_a3[pe], 1'b0);
            // Assert from $init_pix through $done_pix:
            assign PIPE_Pe_calc_valid_a3[pe] = PIPE_Pe_reset_a3[pe]             ? 1'b0 :
                          PIPE_Pe_init_pix_a4[pe] ? 1'b1 :
                          PIPE_Pe_done_pix_a4[pe] ? 1'b0 :
                                               PIPE_Pe_calc_valid_a4[pe];
            assign PIPE_Pe_done_pix_a3[pe] =
                PIPE_Pe_reset_a3[pe] ? 1'b0 :
                PIPE_out_valid_a4 ? 1'b0 :
                PIPE_Pe_done_pix_a4[pe]       ? 1'b1 : // Hold value until sent (|pipe$out_valid). Must be a 1-iteration loop preventing back-to-back $out_valid.
                                           PIPE_Pe_calc_valid_a3[pe] && (
                                              // a*a + b*b
                                              ({1'b0, PIPE_Pe_aa_sq_plus_bb_sq_a3[pe][2:-29]} >= real_to_fixed({1'b0, 1'b1, 9'b0, 1'b1, 52'b0})
                                              ) ||
                                              // This term catches some overflow cases w/ the multiply and allows fewer int bits to be used.
                                              // |a| >= 2.0 || |b| >= 2.0
                                              (|{PIPE_Pe_aa_a3[pe][3-1:3-3+1],
                                                 PIPE_Pe_bb_a3[pe][3-1:3-3+1]}
                                              ) ||
                                              (PIPE_Pe_depth_a3[pe] == PIPE_max_depth_a3)
                                           );
            //+$not_done = ! $done_pix;

            //?$not_done
            assign PIPE_Pe_aa_sq_minus_bb_sq_a3[pe][3:-29] = fixed_add(PIPE_Pe_aa_sq_a3[pe], PIPE_Pe_bb_sq_a3[pe], 1'b1);
            assign PIPE_Pe_aa_a2[pe][3:-29] = PIPE_Pe_init_pix_a3[pe] ? PIPE_Pe_xx_a3[pe] : fixed_add(PIPE_Pe_aa_sq_minus_bb_sq_a3[pe], PIPE_Pe_xx_a3[pe], 1'b0);
            assign PIPE_Pe_aa_times_bb_a3[pe][3:-29] = fixed_mul(PIPE_Pe_aa_a3[pe], PIPE_Pe_bb_a3[pe]);
            assign PIPE_Pe_aa_times_bb_times_2_a3[pe][3:-29] = {PIPE_Pe_aa_times_bb_a3[pe][3], PIPE_Pe_aa_times_bb_a3[pe][2:-29] << 1};
            assign PIPE_Pe_bb_a2[pe][3:-29] = PIPE_Pe_init_pix_a3[pe] ? PIPE_Pe_yy_a3[pe] : fixed_add(PIPE_Pe_aa_times_bb_times_2_a3[pe], PIPE_Pe_yy_a3[pe], 1'b0);

            assign PIPE_Pe_done_pix_pulse_a3[pe] = PIPE_Pe_done_pix_a3[pe] & ! PIPE_Pe_done_pix_a4[pe];
            assign PIPE_Pe_depth_out_a3[pe][31:0] = PIPE_Pe_done_pix_pulse_a3[pe] ? PIPE_Pe_depth_a3[pe] : PIPE_Pe_depth_out_a4[pe][31:0];
      end
      //_@4
         assign PIPE_all_pix_done_a4 = PIPE_reset_a4 ? '0 : & PIPE_Pe_done_pix_a4 && out_ready;
         //$all_pix_done_pulse = $all_pix_done & ! >>1$all_pix_done;
         assign PIPE_out_data_a4[C_DATA_WIDTH-1:0] = PIPE_Pe_depth_out_a4;
         assign PIPE_out_avail_a4 = PIPE_all_pix_done_a4;
         assign PIPE_out_valid_a4 = PIPE_out_avail_a4 && PIPE_out_ready_a4;
         assign PIPE_done_pixels_a4 = PIPE_out_valid_a4;
         assign PIPE_done_frame_a4 = PIPE_done_pixels_a4 && PIPE_Pe_last_h_a4 & PIPE_Pe_last_v_a4;
      
      // SV<->TLV for outgoing data interface.
      //_@4
         assign out_data = PIPE_out_data_a4;
         assign out_avail = PIPE_out_avail_a4;
         assign PIPE_out_ready_a4 = out_ready;
      
      // Testbench control.
      //_@10
         assign frame_done = PIPE_done_frame_a10;
endgenerate
         

//_\SV
   endmodule
